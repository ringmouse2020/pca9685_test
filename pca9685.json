{"README.md":"\n> Open this page at [https://.github.io//](https://.github.io//)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open []()\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/** and import\n\n## Edit this project ![Build status badge](https://github.com//workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open []()\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com//raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","_locales/zh-CN/pca9685-strings.json":"{\n    \"robotbit.Servo|block\": \"9g舵机|%index|角度 %degree\",\n    \"robotbit.GeekServo|block\": \"Geekservo|9g舵机|%index|角度 %degree\",\n    \"robotbit.GeekServo2KG|block\": \"2KG舵机|%index|角度 %degree\",\n    \"robotbit.StepperDegree|block\": \"步进 28BYJ-48|%index|角度 %degree\",\n    \"robotbit.StepperTurn|block\": \"步进 28BYJ-48|%index|圈数 %turn\",\n    \"robotbit.StepperDual|block\": \"双步进(角度) |M1 %degree1| M2 %degree2\",\n    \"robotbit.StpCarMove|block\": \"步进小车 前进 |距离(cm) %distance|轮直径(mm) %diameter\",\n    \"robotbit.StpCarTurn|block\": \"步进小车 转向 |角度 %turn|轮直径(mm) %diameter|轮距(mm) %track\",\n    \"robotbit.MotorRun|block\": \"电机|%index|速度 %speed\",\n    \"robotbit.MotorRunDual|block\": \"电机|%motor1|速度 %speed1|%motor2|速度 %speed2\",\n    \"robotbit.MotorRunDelay|block\": \"电机|%index|速度 %speed|延时 %delay|s\",\n    \"robotbit.MotorStop|block\": \"电机 停止|%index|\",\n    \"robotbit.MotorStopAll|block\": \"停止所有电机\",\n    \"robotbit.RgbUltrasonic|block\": \"猫耳RGB超声波|引脚 %pin\",\n    \"robotbit.HoleUltrasonic|block\": \"猫耳洞超声波|引脚 %pin\",\n    \"robotbit.MatrixDraw|block\": \"LED矩阵 描点|X %x|Y %y\",\n    \"robotbit.MatrixClear|block\": \"LED矩阵 清空\"\n}","_locales/zh-TW/pca9685-strings.json":"{\n    \"robotbit.Servo|block\": \"9g舵機|%index|角度 %degree\",\n    \"robotbit.GeekServo|block\": \"Geekservo|9g舵機|%index|角度 %degree\",\n    \"robotbit.GeekServo2KG|block\": \"2KG舵機|%index|角度 %degree\",\n    \"robotbit.StepperDegree|block\": \"步進 28BYJ-48|%index|角度 %degree\",\n    \"robotbit.StepperTurn|block\": \"步進 28BYJ-48|%index|圈數 %turn\",\n    \"robotbit.StepperDual|block\": \"雙步進(角度) |M1 %degree1| M2 %degree2\",\n    \"robotbit.StpCarMove|block\": \"步進小車 前進 |距離(cm) %distance|輪直徑(mm) %diameter\",\n    \"robotbit.StpCarTurn|block\": \"步進小車 轉向 |角度 %turn|輪直徑(mm) %diameter|輪距(mm) %track\",\n    \"robotbit.MotorRun|block\": \"馬達|%index|速度 %speed\",\n    \"robotbit.MotorRunDual|block\": \"馬達|%motor1|速度 %speed1|%motor2|速度 %speed2\",\n    \"robotbit.MotorRunDelay|block\": \"馬達|%index|速度 %speed|延時 %delay|s\",\n    \"robotbit.MotorStop|block\": \"馬達 停止|%index|\",\n    \"robotbit.MotorStopAll|block\": \"停止所有馬達\",\n    \"robotbit.RgbUltrasonic|block\": \"貓耳RGB超聲波|腳位 %pin\",\n    \"robotbit.HoleUltrasonic|block\": \"貓耳洞超聲波|腳位 %pin\",\n    \"robotbit.MatrixDraw|block\": \"LED矩陣 描點|X %x|Y %y\",\n    \"robotbit.MatrixClear|block\": \"LED矩陣 清空\"\n}\n\n","main.ts":"/*\r\nRiven\r\nmodified from pxt-servo/servodriver.ts\r\nload dependency\r\n\"pca9685\": \"file:../pxt-pca9685\"\r\n*/\r\n\r\n\r\n//% color=\"#31C7D5\" weight=10 icon=\"\\uf1d0\"\r\nnamespace pca9685 {\r\n    const PCA9685_ADDRESS = 0x40\r\n    const MODE1 = 0x00\r\n    const MODE2 = 0x01\r\n    const SUBADR1 = 0x02\r\n    const SUBADR2 = 0x03\r\n    const SUBADR3 = 0x04\r\n    const PRESCALE = 0xFE\r\n    const LED0_ON_L = 0x06\r\n    const LED0_ON_H = 0x07\r\n    const LED0_OFF_L = 0x08\r\n    const LED0_OFF_H = 0x09\r\n    const ALL_LED_ON_L = 0xFA\r\n    const ALL_LED_ON_H = 0xFB\r\n    const ALL_LED_OFF_L = 0xFC\r\n    const ALL_LED_OFF_H = 0xFD\r\n\r\n    const STP_CHA_L = 2047\r\n    const STP_CHA_H = 4095\r\n\r\n    const STP_CHB_L = 1\r\n    const STP_CHB_H = 2047\r\n\r\n    const STP_CHC_L = 1023\r\n    const STP_CHC_H = 3071\r\n\r\n    const STP_CHD_L = 3071\r\n    const STP_CHD_H = 1023\r\n\r\n    // HT16K33 commands\r\n    const HT16K33_ADDRESS = 0x70\r\n    const HT16K33_BLINK_CMD = 0x80\r\n    const HT16K33_BLINK_DISPLAYON = 0x01\r\n    const HT16K33_BLINK_OFF = 0\r\n    const HT16K33_BLINK_2HZ = 1\r\n    const HT16K33_BLINK_1HZ = 2\r\n    const HT16K33_BLINK_HALFHZ = 3\r\n    const HT16K33_CMD_BRIGHTNESS = 0xE0\r\n\r\n    export enum Servos {\r\n        S0 = 0x00,\r\n        S1 = 0x01,\r\n        S2 = 0x02,\r\n        S3 = 0x03,\r\n        S4 = 0x04,\r\n        S5 = 0x05,\r\n        S6 = 0x06,\r\n        S7 = 0x07,\r\n        S8 = 0x08,\r\n        S9 = 0x09,\r\n        S10 = 0x0a,\r\n        S11 = 0x0b,\r\n        S12 = 0x0c,\r\n        S13 = 0x0d,\r\n        S14 = 0x0e,\r\n        S15 = 0x0f\r\n    }\r\n\r\n    export enum Motors {\r\n        M1A = 0x1,\r\n        M1B = 0x2,\r\n        M2A = 0x3,\r\n        M2B = 0x4\r\n    }\r\n\r\n    export enum Steppers {\r\n        M1 = 0x1,\r\n        M2 = 0x2\r\n    }\r\n\r\n    export enum SonarVersion {\r\n        V1 = 0x1,\r\n        V2 = 0x2\r\n    }\r\n\r\n    export enum Turns {\r\n        //% blockId=\"T1B4\" block=\"1/4\"\r\n        T1B4 = 90,\r\n        //% blockId=\"T1B2\" block=\"1/2\"\r\n        T1B2 = 180,\r\n        //% blockId=\"T1B0\" block=\"1\"\r\n        T1B0 = 360,\r\n        //% blockId=\"T2B0\" block=\"2\"\r\n        T2B0 = 720,\r\n        //% blockId=\"T3B0\" block=\"3\"\r\n        T3B0 = 1080,\r\n        //% blockId=\"T4B0\" block=\"4\"\r\n        T4B0 = 1440,\r\n        //% blockId=\"T5B0\" block=\"5\"\r\n        T5B0 = 1800\r\n    }\r\n\r\n    let initialized = false\r\n\r\n    let matBuf = pins.createBuffer(17);\r\n    let distanceBuf = 0;\r\n\r\n    function i2cwrite(addr: number, reg: number, value: number) {\r\n        let buf = pins.createBuffer(2)\r\n        buf[0] = reg\r\n        buf[1] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2ccmd(addr: number, value: number) {\r\n        let buf = pins.createBuffer(1)\r\n        buf[0] = value\r\n        pins.i2cWriteBuffer(addr, buf)\r\n    }\r\n\r\n    function i2cread(addr: number, reg: number) {\r\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE);\r\n        let val = pins.i2cReadNumber(addr, NumberFormat.UInt8BE);\r\n        return val;\r\n    }\r\n\r\n    function initPCA9685(): void {\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, 0x00)\r\n        setFreq(50);\r\n        for (let idx = 0; idx < 16; idx++) {\r\n            setPwm(idx, 0, 0);\r\n        }\r\n        initialized = true\r\n    }\r\n\r\n    function setFreq(freq: number): void {\r\n        // Constrain the frequency\r\n        let prescaleval = 25000000;\r\n        prescaleval /= 4096;\r\n        prescaleval /= freq;\r\n        prescaleval -= 1;\r\n        let prescale = prescaleval; //Math.Floor(prescaleval + 0.5);\r\n        let oldmode = i2cread(PCA9685_ADDRESS, MODE1);\r\n        let newmode = (oldmode & 0x7F) | 0x10; // sleep\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, newmode); // go to sleep\r\n        i2cwrite(PCA9685_ADDRESS, PRESCALE, prescale); // set the prescaler\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode);\r\n        control.waitMicros(5000);\r\n        i2cwrite(PCA9685_ADDRESS, MODE1, oldmode | 0xa1);\r\n    }\r\n\r\n    function setPwm(channel: number, on: number, off: number): void {\r\n        if (channel < 0 || channel > 15)\r\n            return;\r\n\r\n        let buf = pins.createBuffer(5);\r\n        buf[0] = LED0_ON_L + 4 * channel;\r\n        buf[1] = on & 0xff;\r\n        buf[2] = (on >> 8) & 0xff;\r\n        buf[3] = off & 0xff;\r\n        buf[4] = (off >> 8) & 0xff;\r\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf);\r\n    }\r\n\r\n\r\n    function setStepper(index: number, dir: boolean): void {\r\n        if (index == 1) {\r\n            if (dir) {\r\n                setPwm(0, STP_CHA_L, STP_CHA_H);\r\n                setPwm(2, STP_CHB_L, STP_CHB_H);\r\n                setPwm(1, STP_CHC_L, STP_CHC_H);\r\n                setPwm(3, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(3, STP_CHA_L, STP_CHA_H);\r\n                setPwm(1, STP_CHB_L, STP_CHB_H);\r\n                setPwm(2, STP_CHC_L, STP_CHC_H);\r\n                setPwm(0, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        } else {\r\n            if (dir) {\r\n                setPwm(4, STP_CHA_L, STP_CHA_H);\r\n                setPwm(6, STP_CHB_L, STP_CHB_H);\r\n                setPwm(5, STP_CHC_L, STP_CHC_H);\r\n                setPwm(7, STP_CHD_L, STP_CHD_H);\r\n            } else {\r\n                setPwm(7, STP_CHA_L, STP_CHA_H);\r\n                setPwm(5, STP_CHB_L, STP_CHB_H);\r\n                setPwm(6, STP_CHC_L, STP_CHC_H);\r\n                setPwm(4, STP_CHD_L, STP_CHD_H);\r\n            }\r\n        }\r\n    }\r\n\r\n    function stopMotor(index: number) {\r\n        setPwm((index - 1) * 2, 0, 0);\r\n        setPwm((index - 1) * 2 + 1, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Servo Execute\r\n     * @param index Servo Channel; eg: S1\r\n     * @param degree [0-180] degree of servo; eg: 0, 90, 180\r\n    */\r\n    //% blockId=pca9685_servo block=\"Servo|%index|degree %degree\"\r\n    //% weight=100\r\n    //% degree.min=0 degree.max=180\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function Servo(index: Servos, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let v_us = (degree * 1800 / 180 + 600) // 0.6 ~ 2.4\r\n        let value = v_us * 4096 / 20000\r\n        setPwm(index, 0, value)\r\n    }\r\n\r\n    /**\r\n     * Geek Servo\r\n     * @param index Servo Channel; eg: S1\r\n     * @param degree [-45-225] degree of servo; eg: -45, 90, 225\r\n    */\r\n    //% blockId=pca9685_gservo block=\"Geek Servo|%index|degree %degree\"\r\n    //% weight=99\r\n    //% blockGap=50\r\n    //% degree.min=-45 degree.max=225\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function GeekServo(index: Servos, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        let v_us = ((degree - 90) * 20 / 3 + 1500) // 0.6 ~ 2.4\r\n        let value = v_us * 4096 / 20000\r\n        setPwm(index, 0, value)\r\n    }\r\n\r\n    /**\r\n     * GeekServo2KG\r\n     * @param index Servo Channel; eg: S1\r\n     * @param degree [0-360] degree of servo; eg: 0, 180, 360\r\n    */\r\n    //% blockId=pca9685_gservo2kg block=\"GeekServo2KG|%index|degree %degree\"\r\n    //% weight=98\r\n    //% blockGap=50\r\n    //% degree.min=0 degree.max=360\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function GeekServo2KG(index: Servos, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        // 50hz: 20,000 us\r\n        //let v_us = (degree * 2000 / 360 + 500)  0.5 ~ 2.5\r\n        let v_us = (Math.floor((degree) * 2000 / 350) + 500) //fixed\r\n        let value = v_us * 4096 / 20000\r\n        setPwm(index, 0, value)\r\n    }\r\n\r\n    //% blockId=pca9685_stepper_degree block=\"Stepper 28BYJ-48|%index|degree %degree\"\r\n    //% weight=90\r\n    export function StepperDegree(index: Steppers, degree: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setStepper(index, degree > 0);\r\n        degree = Math.abs(degree);\r\n        basic.pause(10240 * degree / 360);\r\n        MotorStopAll()\r\n    }\r\n\r\n\r\n    //% blockId=pca9685_stepper_turn block=\"Stepper 28BYJ-48|%index|turn %turn\"\r\n    //% weight=90\r\n    export function StepperTurn(index: Steppers, turn: Turns): void {\r\n        let degree = turn;\r\n        StepperDegree(index, degree);\r\n    }\r\n\r\n    //% blockId=pca9685_stepper_dual block=\"Dual Stepper(Degree) |M1 %degree1| M2 %degree2\"\r\n    //% weight=89\r\n    export function StepperDual(degree1: number, degree2: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        setStepper(1, degree1 > 0);\r\n        setStepper(2, degree2 > 0);\r\n        degree1 = Math.abs(degree1);\r\n        degree2 = Math.abs(degree2);\r\n        basic.pause(10240 * Math.min(degree1, degree2) / 360);\r\n        if (degree1 > degree2) {\r\n            stopMotor(3); stopMotor(4);\r\n            basic.pause(10240 * (degree1 - degree2) / 360);\r\n        } else {\r\n            stopMotor(1); stopMotor(2);\r\n            basic.pause(10240 * (degree2 - degree1) / 360);\r\n        }\r\n\r\n        MotorStopAll()\r\n    }\r\n\r\n    /**\r\n     * Stepper Car move forward\r\n     * @param distance Distance to move in cm; eg: 10, 20\r\n     * @param diameter diameter of wheel in mm; eg: 48\r\n    */\r\n    //% blockId=pca9685_stpcar_move block=\"Car Forward|Distance(cm) %distance|Wheel Diameter(mm) %diameter\"\r\n    //% weight=88\r\n    export function StpCarMove(distance: number, diameter: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        let delay = 10240 * 10 * distance / 3 / diameter; // use 3 instead of pi\r\n        setStepper(1, delay > 0);\r\n        setStepper(2, delay > 0);\r\n        delay = Math.abs(delay);\r\n        basic.pause(delay);\r\n        MotorStopAll()\r\n    }\r\n\r\n    /**\r\n     * Stepper Car turn by degree\r\n     * @param turn Degree to turn; eg: 90, 180, 360\r\n     * @param diameter diameter of wheel in mm; eg: 48\r\n     * @param track track width of car; eg: 125\r\n    */\r\n    //% blockId=pca9685_stpcar_turn block=\"Car Turn|Degree %turn|Wheel Diameter(mm) %diameter|Track(mm) %track\"\r\n    //% weight=87\r\n    //% blockGap=50\r\n    export function StpCarTurn(turn: number, diameter: number, track: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        let delay = 10240 * turn * track / 360 / diameter;\r\n        setStepper(1, delay < 0);\r\n        setStepper(2, delay > 0);\r\n        delay = Math.abs(delay);\r\n        basic.pause(delay);\r\n        MotorStopAll()\r\n    }\r\n\r\n    //% blockId=pca9685_motor_run block=\"Motor|%index|speed %speed\"\r\n    //% weight=85\r\n    //% speed.min=-255 speed.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRun(index: Motors, speed: number): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        speed = speed * 16; // map 255 to 4096\r\n        if (speed >= 4096) {\r\n            speed = 4095\r\n        }\r\n        if (speed <= -4096) {\r\n            speed = -4095\r\n        }\r\n        if (index > 4 || index <= 0)\r\n            return\r\n        let pp = (index - 1) * 2\r\n        let pn = (index - 1) * 2 + 1\r\n        if (speed >= 0) {\r\n            setPwm(pp, 0, speed)\r\n            setPwm(pn, 0, 0)\r\n        } else {\r\n            setPwm(pp, 0, 0)\r\n            setPwm(pn, 0, -speed)\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Execute two motors at the same time\r\n     * @param motor1 First Motor; eg: M1A, M1B\r\n     * @param speed1 [-255-255] speed of motor; eg: 150, -150\r\n     * @param motor2 Second Motor; eg: M2A, M2B\r\n     * @param speed2 [-255-255] speed of motor; eg: 150, -150\r\n    */\r\n    //% blockId=pca9685_motor_dual block=\"Motor|%motor1|speed %speed1|%motor2|speed %speed2\"\r\n    //% weight=84\r\n    //% speed1.min=-255 speed1.max=255\r\n    //% speed2.min=-255 speed2.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRunDual(motor1: Motors, speed1: number, motor2: Motors, speed2: number): void {\r\n        MotorRun(motor1, speed1);\r\n        MotorRun(motor2, speed2);\r\n    }\r\n\r\n    /**\r\n     * Execute single motors with delay\r\n     * @param index Motor Index; eg: M1A, M1B, M2A, M2B\r\n     * @param speed [-255-255] speed of motor; eg: 150, -150\r\n     * @param delay seconde delay to stop; eg: 1\r\n    */\r\n    //% blockId=pca9685_motor_rundelay block=\"Motor|%index|speed %speed|delay %delay|s\"\r\n    //% weight=81\r\n    //% speed.min=-255 speed.max=255\r\n    //% name.fieldEditor=\"gridpicker\" name.fieldOptions.columns=4\r\n    export function MotorRunDelay(index: Motors, speed: number, delay: number): void {\r\n        MotorRun(index, speed);\r\n        basic.pause(delay * 1000);\r\n        MotorRun(index, 0);\r\n    }\r\n\r\n\r\n\r\n    //% blockId=pca9685_stop block=\"Motor Stop|%index|\"\r\n    //% weight=80\r\n    export function MotorStop(index: Motors): void {\r\n        MotorRun(index, 0);\r\n    }\r\n\r\n    //% blockId=pca9685_stop_all block=\"Motor Stop All\"\r\n    //% weight=79\r\n    //% blockGap=50\r\n    export function MotorStopAll(): void {\r\n        if (!initialized) {\r\n            initPCA9685()\r\n        }\r\n        for (let idx = 1; idx <= 4; idx++) {\r\n            stopMotor(idx);\r\n        }\r\n    }\r\n\r\n    //% blockId=pca9685_rgb_ultrasonic block=\"rgbUltrasonic|pin %pin\"\r\n    //% weight=11\r\n    export function RgbUltrasonic(pin: DigitalInOutPin): number {\r\n\r\n        // send pulse\r\n        pin.setPull(PinPullMode.PullNone);\r\n        pin.digitalWrite(false);\r\n        control.waitMicros(2);\r\n        pin.digitalWrite(true);\r\n        control.waitMicros(10);\r\n        pin.digitalWrite(false);\r\n\r\n        // read pulse\r\n        let d = pin.pulseIn(PulseValue.High, 25000);\r\n        let ret = d;\r\n        // filter timeout spikes\r\n        if (ret == 0 && distanceBuf != 0) {\r\n            ret = distanceBuf;\r\n        }\r\n        distanceBuf = d;\r\n        return Math.floor(ret * 10 / 6 / 58);\r\n    }\r\n\r\n    //% blockId=pca9685_hole_ultrasonic block=\"holeUltrasonic|pin %pin\"\r\n    //% weight=10\r\n    export function HoleUltrasonic(pin: DigitalInOutPin): number {\r\n\r\n        // send pulse\r\n        pin.setPull(PinPullMode.PullDown);\r\n        pin.digitalWrite(false);\r\n        control.waitMicros(2);\r\n        pin.digitalWrite(true);\r\n        control.waitMicros(10);\r\n        pin.digitalWrite(false);\r\n\r\n        // read pulse\r\n        let d = pin.pulseIn(PulseValue.High, 25000);\r\n        let ret = d;\r\n        // filter timeout spikes\r\n        if (ret == 0 && distanceBuf != 0) {\r\n            ret = distanceBuf;\r\n        }\r\n        distanceBuf = d;\r\n        return Math.floor(ret / 40 + (ret / 800));\r\n    }\r\n\r\n}\r\n","pxt.json":"{\n    \"name\": \"pca9685\",\n    \"version\": \"0.0.0\",\n    \"description\": \"MCP23017 Io Expansion Borad for Microbit\",\n    \"license\": \"MIT\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.ts\",\n        \"_locales/zh-CN/pca9685-strings.json\",\n        \"_locales/zh-TW/pca9685-strings.json\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"branch\": \"v3.1.87\",\n        \"tag\": \"v3.1.87\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/4b79db779ce24b3244930f45b94033f20c019886\",\n        \"target\": \"3.1.87\",\n        \"pxt\": \"6.13.42\"\n    },\n    \"preferredEditor\": \"tsprj\"\n}\n"}